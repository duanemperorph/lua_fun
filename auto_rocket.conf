# This is a file describing a standard autoconfiguration, do not edit.
# See custom/sample.conf for a more generic template and explanation on the syntax.

name: Auto Rocket

slots:
    core:
        class: CoreUnit
    antigrav:
        class: AntiGravityGeneratorUnit
    warpdrive:
        class: WarpDriveUnit
    atmofueltank:
        class: AtmoFuelContainer
        select: all
    spacefueltank:
        class: SpaceFuelContainer
        select: all
    rocketfueltank:
        class: RocketFuelContainer
        select: all
    spacebrake:
        class: Spacebrake
    gyro:
        class: GyroUnit
    weapon:
        class: WeaponUnit
        select: manual
    radar:
        class: RadarPVPUnit
        select: manual

handlers:
    unit:
        start:
            lua: |

                --- NAV POINTS ---
                nav1 = {
                    name = "spazPad",
                    loc = "::pos{0,26,-6.9926,3.6189,66.9041}",
                    planetDepth = 83400
                }

                nav2 = {
                    name = "spazBaz",
                    loc = "::pos{0,0,-1233489.8236,463419.2081,-317880.0588}",
                }

                nav3 = {
                    name = "Sanc 6",
                    loc = "::pos{0,26,12.3192,169.8873,39.2892}",
                    planetDepth = 83400
                }

                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setTargetGroundAltitude(4)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 2000, 5000, 10000, 100000, 1000000})

                -- element widgets
                -- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.
                _autoconf.displayCategoryPanel(weapon, weapon_size, L_TEXT("ui_lua_widget_weapon", "Weapons"), "weapon", true)
                core.show()
                _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_periscope", "Periscope"), "periscope")
                placeRadar = true
                if atmofueltank_size > 0 then
                    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"), "fuel_container")
                    if placeRadar then
                        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        placeRadar = false
                    end
                end
                if spacefueltank_size > 0 then
                    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"), "fuel_container")
                    if placeRadar then
                        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        placeRadar = false
                    end
                end
                _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"), "fuel_container")
                if placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels
                    _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                    placeRadar = false
                end
                if antigrav ~= nil then antigrav.show() end
                if warpdrive ~= nil then warpdrive.show() end
                if gyro ~= nil then gyro.show() end

                -- freeze the player in he is remote controlling the construct
                if Nav.control.isRemoteControlled() == 1 then
                    system.freeze(1)
                end

                -- landing gear
                -- make sure every gears are synchonized with the first
                gearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end

                autopilotPanel = system.createWidgetPanel("Autopilot")
                autopilotWidget = system.createWidget(autopilotPanel, "value")
                modeWidgetData = system.createData()
                system.addDataToWidget(modeWidgetData, autopilotWidget)
                stageWidgetData = system.createData()
                system.addDataToWidget(stageWidgetData, autopilotWidget)
                brakeWidgetData = system.createData()
                system.addDataToWidget(brakeWidgetData, autopilotWidget)
                engineCutWidgetData = system.createData()
                system.addDataToWidget(engineCutWidgetData, autopilotWidget)
                hoverSlamWidgetData = system.createData()
                system.addDataToWidget(hoverSlamWidgetData, autopilotWidget)

                navPanel = system.createWidgetPanel("Nav")
                navWidget = system.createWidget(navPanel, "value")
                navNameData = system.createData()
                navTypeData = system.createData()
                navWPData = system.createData()
                navDistanceData = system.createData()
                system.addDataToWidget(navNameData, navWidget)
                system.addDataToWidget(navTypeData, navWidget)
                system.addDataToWidget(navDistanceData, navWidget)
                system.addDataToWidget(navWPData, navWidget)

                velocityPanel = system.createWidgetPanel("Current Velocity")
                velocityWidget = system.createWidget(velocityPanel, 'value')
                velocityXData = system.createData()
                velocityYData = system.createData()
                velocityZData = system.createData()
                system.addDataToWidget(velocityXData, velocityWidget)
                system.addDataToWidget(velocityYData, velocityWidget)
                system.addDataToWidget(velocityZData, velocityWidget)

                targetVelocityPanel = system.createWidgetPanel("Target Velocity")
                targetVelocityWidget = system.createWidget(targetVelocityPanel, 'value')
                targetVelocityXData = system.createData()
                targetVelocityYData = system.createData()
                targetVelocityZData = system.createData()
                system.addDataToWidget(targetVelocityXData, targetVelocityWidget)
                system.addDataToWidget(targetVelocityYData, targetVelocityWidget)
                system.addDataToWidget(targetVelocityZData, targetVelocityWidget)

                debugPanel = system.createWidgetPanel("Debug")
                debugWidget = system.createWidget(debugPanel, "value")
                debugData1 = system.createData()
                debugData2 = system.createData()
                debugData3 = system.createData()
                debugData4 = system.createData()
                debugData5 = system.createData()
                debugData6 = system.createData()
                -- debugData7 = system.createData()
                -- debugData8 = system.createData()
                -- debugData9 = system.createData()
                system.addDataToWidget(debugData1, debugWidget)
                system.addDataToWidget(debugData2, debugWidget)
                system.addDataToWidget(debugData3, debugWidget)
                system.addDataToWidget(debugData4, debugWidget)
                system.addDataToWidget(debugData5, debugWidget)
                system.addDataToWidget(debugData6, debugWidget)
                -- system.addDataToWidget(debugData7, debugWidget)
                -- system.addDataToWidget(debugData8, debugWidget)
                -- system.addDataToWidget(debugData9, debugWidget)

                updateValueWidgetData = function(widget, label, value, units)
                    local data = '{"label": "_LABEL_", "value": "_VALUE_", "unit": "_UNIT_"}'
                    data = string.gsub(data, '_LABEL_', label)
                    data = string.gsub(data, '_VALUE_', value)
                    data = string.gsub(data, '_UNIT_', units or '')
                    system.updateData(widget, data)
                end

                updateAutopilotWidget = function()
                    local autopilotModeName = ""

                    if (autopilotMode == AUTOPILOT_MODE_MANUAL) then
                        autopilotModeName = 'Manual (1)'
                    elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                        autopilotModeName = "Hover (2)"
                    elseif autopilotMode == AUTOPILOT_MODE_SPACE_ASSIST then
                        autopilotModeName = "Space Asist (3)"
                    elseif autopilotMode == AUTOPILOT_MODE_LAUNCH then
                        autopilotModeName = "Launch (4)"
                    elseif autopilotMode == AUTOPILOT_MODE_CRUISE then
                        autopilotModeName = "Cruise (5)"
                    elseif autopilotMode == AUTOPILOT_MODE_DESCENT then
                        autopilotModeName = "Descent (6.1)"
                    elseif autopilotMode == AUTOPILOT_MODE_APPROACH then
                        autopilotModeName = "Approach (6)"
                    end

                    updateValueWidgetData(modeWidgetData, 'MODE', autopilotModeName)
                end

                updatePanels = function() 
                    updateValueWidgetData(stageWidgetData, 'STAGE', autopilotStage)
                    updateValueWidgetData(brakeWidgetData, 'BRAKE', brakeAcceleration:len())
                    updateValueWidgetData(engineCutWidgetData, 'ENGINE CUT', engineCut)
                    updateValueWidgetData(hoverSlamWidgetData, 'HOVER SLAM', hoverSlamArmed)

                    updateAutopilotWidget()

                    local vel = vec3(core.getVelocity())

                    updateValueWidgetData(velocityXData, 'x', formatNumber(vel.x))
                    updateValueWidgetData(velocityYData, 'y', formatNumber(vel.y))
                    updateValueWidgetData(velocityZData, 'z', formatNumber(vel.z))

                    updateValueWidgetData(targetVelocityXData, 'x', formatNumber(xTargetVel))
                    updateValueWidgetData(targetVelocityYData, 'y', formatNumber(yTargetVel))
                    updateValueWidgetData(targetVelocityZData, 'z', formatNumber(zTargetVel))

                    updateValueWidgetData(debugData1, 'x', formatNumber(debugVec.x))
                    updateValueWidgetData(debugData2, 'y', formatNumber(debugVec.y))
                    updateValueWidgetData(debugData3, 'z', formatNumber(debugVec.z))

                    debugVal1 = getMaxSpaceBrakeAccel()
                    updateValueWidgetData(debugData4, 'max space braking', formatNumber(debugVal1))

                    debugVal2 = getMaxRocketAccel()
                    updateValueWidgetData(debugData5, 'max rocket accel', formatNumber(debugVal2))

                    debugVal3 = getRocketFuelMass()
                    updateValueWidgetData(debugData6, 'fuel mass', formatNumber(debugVal3))

                    updateNavWidget()
                end

                function formatNumber(num) 
                    local base = 100
                    return math.floor(num * base) / base
                end

                -- Initial auto pilot mode
                setAutopilotMode(AUTOPILOT_MODE_MANUAL)

                function selectNavPoint(newNav) 
                    local systemNum, planetNum, lat, long, alt = newNav.loc:match("([%d//.-]+),([%d//.-]+),([%d//.-]+),([%d//.-]+),([%d//.-]+)")

                    -- Space coordinates
                    if math.ceil(planetNum) == 0 then
                        local navX = lat
                        local navY = long
                        local navZ = alt
                        navSpacePos = vec3(navX, navY, navZ)
                        navLat = 0
                        navLong = 0
                        navAlt = 0
                        navType = NAV_TYPE_SPACE
                        navSurfacePos = nil
                        navApproachDistance = NAV_APPROACH_DISTANCE
                    else
                        navLat = lat
                        navLong = long
                        navAlt = alt
                        navType = NAV_TYPE_PLANET
                        navPlanetDepth = newNav.planetDepth
                        navApproachDistance = 0
                        updateNavSpacePos()
                        updateNavSurfacePos()
                    end

                    navName = newNav.name
                end

                function updateNavWidget() 
                    updateValueWidgetData(navNameData, 'Name', navName)
                    updateValueWidgetData(navTypeData, 'Type', navType)
                    local destPos = getWaypointPos()
                    local currentPos = vec3(core.getConstructWorldPos())
                    local deltaPos = destPos - currentPos
                    local distance = deltaPos:len()
                    updateValueWidgetData(navDistanceData, 'WP Distance', formatNumber(distance))
                    updateValueWidgetData(navWPData, "WP Count", currentWaypoint)
                end

                selectNavPoint(nav1)

                -- Waypoint generation
                function generateRadialWaypoints()
                    -- Don't do this if we're not closes enough to the planet
                    if navType ~= NAV_TYPE_PLANET or core.getAltitude() == 0 then
                        return
                    end

                    local theCenter = getTheCenter()
                    local navToCenter = navSpacePos - theCenter
                    local normNavToCenter = navToCenter:normalize()
                    local currentPosToCenter = vec3(core.getConstructWorldPos()) - theCenter
                    local normCurrentPosToCenter = currentPosToCenter:normalize()

                    -- Geneate CS
                    local csZ = normNavToCenter:cross(normCurrentPosToCenter):normalize_inplace()
                    local csX = normCurrentPosToCenter
                    local csY = csX:cross(csZ):normalize_inplace()
                    local csMatrix = createMatrix(csX, csY, csZ)
                    local cvMatrix = matrixInvert(csMatrix)
                    local cvNavTo = matrixXVec(cvMatrix, normNavToCenter)
                    debugVec = cvNavTo
                    local deltaAngle = math.acos(cvNavTo.x) * getSign(cvNavTo.y)
                    local wpGap = RADIAL_WP_GAP_DEG * constants.deg2rad
                    local wpCount = math.floor(deltaAngle / wpGap)
                    currentWaypoint = wpCount
                    local radius = navPlanetDepth + RADIAL_WP_ALT

                    for i=1, wpCount do
                        local currentAngle = i * wpGap
                        local x = math.cos(currentAngle)
                        local y = math.sin(currentAngle)
                        local currentVec = vec3(x, y, 0)
                        local worldVec = matrixXVec(csMatrix, currentVec)
                        additionalWaypoints[wpCount - i + 1] = worldVec * radius + theCenter
                    end
                end
        stop:
            lua: |
                _autoconf.hideCategoryPanels()
                if antigrav ~= nil then antigrav.hide() end
                if warpdrive ~= nil then warpdrive.hide() end
                if gyro ~= nil then gyro.hide() end
                core.hide()
                Nav.control.switchOffHeadlights()

        tick:
            args: [LAUNCH_RAMP_UP_TIMER]
            lua: |
                setAutopilotStage(LAUNCH_STAGE_ENGINE_ACCENT)
                unit.stopTimer('LAUNCH_RAMP_UP_TIMER')

        tick:
                args: [COURSE_CORRECTION_TIMER]
                lua: |
                    if (autopilotMode == AUTOPILOT_MODE_APPROACH) then
                        updateApproachTick()
                    end

    system:
        start:
            lua: |
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu
                LAUNCH_MAX_ALTITUDE = 3000 --export: Altitude for rocket burn cut off
                LAUNCH_MAX_VELOCITY = 500 --export: velocity for rocket burn cut off
                LAUNCH_MIN_FUEL_MASS = 160 --export: Min fuel capacity mass reminaing for rocket burn

                DESCENT_SURFACE_VELOCITY = 100 --export: Velocity during final descent (m/s)
                DESCENT_SPACE_VELOCITY = 200 --export: Velocity while descending in space above min decell alt(m/s)
                DESCENT_STOP_ALT = 1000 --export: attempt to stop after this alt (in addition to nav alt)
                DESCENT_START_ALT = 15000 --export: Auto-approach will try to reach this alt before descent (m)
                DESCENT_MIN_BRAKE_ALT = 10000 --export: Descent will always brake after this alt (m)

                AUTO_CRUISE_DEFAULT_VELOCITY = 300 --export: Default velocity for autopilot cruise modes (m/s)

                NAV_APPROACH_DISTANCE = 300 --export: Approach distance for space navigation (m)

                RADIAL_WP_GAP_DEG = 30 --export: (deg)
                RADIAL_WP_ALT = 30000 --export: alt (m)
                RADIAL_WP_RADIUS = 1000 --export: (m)

                pitchSpeedFactor = 0.8 --his factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                yawSpeedFactor =  1 --This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                rollSpeedFactor = 1.5 --This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                brakeSpeedFactor = 3 -- When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                brakeFlatFactor = 1 --When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                MAX_ACCELERATION = 1000
                MAX_AUTO_SPEED = 100000

                ENGINE_RAMP_UP_TIME = 6
                SPACE_BRAKE_COUNT = 4
                SLAM_TARGET_ALT = 0 --attempt to stop at this altitude using rocket motor (in addition to nav alt)
                SLAM_MAX_SPEED = 20 --enable emergency hoverslam if we're going faster than this
                DESCENT_FINAL_VELOCTIY = 18 -- VELOCITY WHILE during final hover mode landing

                -- ENTER THE MATRIX
                function createMatrix(vx, vy, vz)
                    local matrix = {
                        { vx.x, vx.y, vx.z },
                        { vy.x, vy.y, vy.z },
                        { vz.x, vz.y, vz.z }
                    }
                    return matrix
                end       
                
                function matrixToString(mat)
                    return string.format("[%+0.3f,%+0.3f,%+0.3f]\n[%+0.3f,%+0.3f,%+0.3f]\n[%+0.3f,%+0.3f,%+0.3f]\n", 
                        mat[1][1], mat[1][2], mat[1][3],
                        mat[2][1], mat[2][2], mat[2][3],
                        mat[3][1], mat[3][2], mat[3][3])
                end
                
                function getDeterminant(v1, v2, v3, v4)
                    return v1 * v4 - v2 * v3
                end
                
                function matrixTranspose(mat)
                    local mt = {{}, {}, {}}
                    
                    for r=1,3 do
                        for c=1,3 do
                            mt[r][c] = mat[c][r]
                        end
                    end
                    return mt
                end
                
                function matrixXScalar(mat, s)
                    local mt = {{}, {}, {}}
                    
                    for r=1,3 do
                        for c=1,3 do
                            mt[r][c] = mat[r][c] * s
                        end
                    end
                    return mt
                end
                
                function matrixInvert(mat)
                    local m1 = {{}, {}, {}}
                    m1[1][1] = getDeterminant(mat[2][2], mat[2][3], mat[3][2], mat[3][3])
                    m1[1][2] = -getDeterminant(mat[2][1], mat[2][3], mat[3][1], mat[3][3])
                    m1[1][3] = getDeterminant(mat[2][1], mat[2][2], mat[3][1], mat[3][2])
                
                    m1[2][1] = -getDeterminant(mat[1][2], mat[1][3], mat[3][2], mat[3][3])
                    m1[2][2] = getDeterminant(mat[1][1], mat[1][3], mat[3][1], mat[3][3])
                    m1[2][3] = -getDeterminant(mat[1][1], mat[1][2], mat[3][1], mat[3][2])
                
                    m1[3][1] = getDeterminant(mat[1][2], mat[1][3], mat[2][2], mat[2][3])
                    m1[3][2] = -getDeterminant(mat[1][1], mat[1][3], mat[2][1], mat[2][3])
                    m1[3][3] = getDeterminant(mat[1][1], mat[1][2], mat[2][1], mat[2][2])
                    
                    local det1 = mat[1][1] * m1[1][1] + mat[1][2] * m1[1][2] + mat[1][3] * m1[1][3]
                
                    return matrixXScalar(matrixTranspose(m1), 1 / det1)
                end
                
                function matrixXMatrix(m1, m2)
                    local mt = {{}, {}, {}}
                
                    for r=1,3 do
                        for c=1,3 do
                            mt[r][c] = m1[r][1] * m2[1][c] + m1[r][2] * m2[2][c] + m1[r][3] * m2[3][c]
                        end
                    end
                    return mt
                end
                
                function matrixXVec(mat, vec) 
                    local x = mat[1][1] * vec.x + mat[2][1] * vec.y + mat[3][1] * vec.z
                    local y = mat[1][2] * vec.x + mat[2][2] * vec.y + mat[3][2] * vec.z
                    local z = mat[1][3] * vec.x + mat[2][3] * vec.y + mat[3][3] * vec.z
                    return vec3(x, y, z)
                end
                -- EXIT THE MATRIX

                -- BEGIN FUN MATH

                function solveQuad(a, b, c)
                    local det = b * b - 4 * a * c
                    return (-b + math.sqrt(det)) / (2 * a)
                end

                function getSign(val)
                    if val >= 0 then
                        return 1
                    else 
                        return -1
                    end
                end

                -- END FUN MATH

                autopilotMode = 0
                autopilotStage = 0

                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput = 0
                brakeAcceleration = vec3(0,0,0)
                engineCut = 0
                gearExtended = false
                hoverSlamArmed = 0

                targetRollDeg =  0
                targetPitchDeg =  0

                longitudinalAcceleration = 0
                lateralAcceleration = 0 
                verticalAcceleration = 0

                rollPID = pid.new(0.2, 0, 10)
                pitchPID = pid.new(0.2, 0, 10)

                xAccelPID = pid.new(1, 0, 50)
                yAccelPID = pid.new(1, 0, 50)
                zAccelPID = pid.new(1, 0, 50)

                xTargetVel = 0
                yTargetVel = 0
                zTargetVel = 0

                -- Auto align
                rz = vec3(1, 0, 0) -- rotation axis
                autoAlignMatrix = createMatrix(vec3(1, 0, 0),vec3(0, 1, 0),vec3(0, 0, 1))
                autoAlignPID = pid.new(0.2, 0, 100)

                -- Auto approach
                autoAccelerationVector = vec3(0, 0, 0)

                -- Auto translate
                xTargetVelPID = pid.new(0.1, 0, 1)
                yTargetVelPID = pid.new(0.1, 0, 1)
                zTargetVelPID = pid.new(0.1, 0, 1)
                localDeltaPos = vec3(0, 0, 0)

                -- Selected nav point
                navLong = 0
                navLat = 0
                navAlt = 0
                navType = 0
                navSurfacePos = nil
                navSpacePos = nil
                navName = ""
                navPlanetDepth = 0
                navApproachDistance = 0

                -- Additional waypoints
                currentWaypoint = 0
                additionalWaypoints = {}

                leftShiftPressed = false
                autoBrakeEnabled = false

                debugVec = vec3(0, 0, 0)
                debugVal1 = 0
                debugVal2 = 0
                debugVal3 = 0

                AUTOPILOT_MODE_MANUAL = 1
                AUTOPILOT_MODE_HOVER = 2
                AUTOPILOT_MODE_SPACE_ASSIST = 3
                AUTOPILOT_MODE_LAUNCH = 4
                AUTOPILOT_MODE_CRUISE = 5
                AUTOPILOT_MODE_APPROACH = 6
                AUTOPILOT_MODE_DESCENT = 16

                LAUNCH_STAGE_ARMED = 0
                LAUNCH_STAGE_ENGINE_RAMP_UP = 1
                LAUNCH_STAGE_ENGINE_ACCENT = 2
                LAUNCH_STAGE_ROCKET_ACCENT = 3

                APPROACH_STAGE_ACCELERATE = 0
                APPROACH_STAGE_BRAKE = 1

                NAV_TYPE_SPACE = 0
                NAV_TYPE_PLANET = 1

                setAutopilotMode = function (newMode)
                    local vel = vec3(core.getVelocity())

                    autopilotMode = newMode
                    autoBrakeEnabled = false
                    xTargetVel = 0
                    yTargetVel = 0
                    zTargetVel = 0
                    targetRollDeg =  0
                    targetPitchDeg =  0

                    local vel = vec3(core.getVelocity())

                    updateNavSpacePos()
                    updateNavSurfacePos()

                    if autopilotMode == AUTOPILOT_MODE_MANUAL then
                        pitchInput = 0
                        rollInput = 0
                        yawInput = 0
                        brakeInput = 0
                        longitudinalAcceleration = 0
                        lateralAcceleration = 0
                        verticalAcceleration = 0
                    elseif autopilotMode == AUTOPILOT_MODE_APPROACH then
                        autoAlignPID:reset()
                        updateApproachTick()
                    elseif autopilotMode == AUTOPILOT_MODE_CRUISE then
                        zTargetVel = AUTO_CRUISE_DEFAULT_VELOCITY
                    end

                    -- configure  hover slam
                    if autopilotMode == AUTOPILOT_MODE_DESCENT then 
                        hoverSlamArmed = 1
                    end

                    -- configure pids
                    if autopilotMode == AUTOPILOT_MODE_DESCENT then
                        -- Higher response PIDs for descent
                        xAccelPID = pid.new(1, 0, 1)
                        yAccelPID = pid.new(1, 0, 1)
                        zAccelPID = pid.new(1, 0, 1)
                    else
                        xAccelPID = pid.new(1, 0, 50)
                        yAccelPID = pid.new(1, 0, 50)
                        zAccelPID = pid.new(1, 0, 50)
                    end

                    setBoosters(false)
                    setAutopilotStage(0)
                end
                
                setAutopilotStage = function (newStage)
                    autopilotStage = newStage

                    if autopilotMode == AUTOPILOT_MODE_LAUNCH then
                        if autopilotStage == LAUNCH_STAGE_ARMED then
                            autoBrakeEnabled = true
                        elseif autopilotStage == LAUNCH_STAGE_ENGINE_RAMP_UP then 
                            autoBrakeEnabled = false
                            longitudinalAcceleration = 0
                            lateralAcceleration = 0
                            verticalAcceleration = MAX_ACCELERATION
                            gearExtended = unit.isAnyLandingGearExtended() == 1
                            unit.setTimer('LAUNCH_RAMP_UP_TIMER', ENGINE_RAMP_UP_TIME)
                        elseif autopilotStage == LAUNCH_STAGE_ROCKET_ACCENT then
                            setBoosters(true)
                        end
                    end
                end

                updateAutopilot = function() 
                    local alt = core.getAltitude()
                    local vel = vec3(core.getVelocity())
                    local accel = vec3(core.getAcceleration())

                    if autopilotMode == AUTOPILOT_MODE_LAUNCH then
                        if vel.z > 1 and gearExtended then
                            unit.retractLandingGears()
                            gearExtended = false
                        end

                        if autopilotStage == LAUNCH_STAGE_ENGINE_ACCENT and accel.z <= 0 then
                            setAutopilotStage(LAUNCH_STAGE_ROCKET_ACCENT)
                        elseif autopilotStage == LAUNCH_STAGE_ROCKET_ACCENT and (vel.z >= LAUNCH_MAX_VELOCITY or alt >= LAUNCH_MAX_ALTITUDE or getRocketFuelMass() <= LAUNCH_MIN_FUEL_MASS) then
                            setAutopilotMode(AUTOPILOT_MODE_CRUISE)
                        end
                    elseif autopilotMode == AUTOPILOT_MODE_DESCENT then
                        updateAutoDescent()
                    elseif autopilotMode == AUTOPILOT_MODE_CRUISE then
                        if Nav.axisCommandManager:getMasterMode() == 1 then
                            zTargetVel = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) * constants.kph2m
                        end
                    elseif autopilotMode == AUTOPILOT_MODE_APPROACH then
                        updateApproachFrame()
                    end
                   
                    if hoverSlamArmed == 1 and (autopilotMode == AUTOPILOT_MODE_DESCENT or autopilotMode == AUTOPILOT_MODE_HOVER) and unit.getClosestPlanetInfluence() > 0 then 
                        if Nav.boosterState == 0 and vel.z < -SLAM_MAX_SPEED then
                            local targetAlt = SLAM_TARGET_ALT + navAlt
                            -- TODO: Fix hover slam
                            local brakeAccel = getMaxRocketAccel()
                            -- TODO: Add atmo engine thrust variation
                            local gravAccel = -core.g()
                            local airResistance = core.g() + accel.z
                            local brakeDist = (vel.z / 2) * (vel.z / (brakeAccel + gravAccel + airResistance * 1.0))
                            local landingDist = alt - targetAlt

                            if landingDist < brakeDist then 
                                setBoosters(true)
                            end
                        elseif Nav.boosterState == 1 and vel.z >= 0 then
                            hoverSlamArmed = 0
                            setBoosters(false)
                        end
                    end
                end

                setBoosters = function (enabled)
                    if enabled then
                        Nav.boosterState = 1
                    else 
                        Nav.boosterState = 0
                    end
                    Nav.boosterStateHasChanged = true
                end

                -- for space assist and hover modes
                function getTargetSpeed()
                    if Nav.axisCommandManager:getMasterMode() == 1 then
                        return Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) * constants.kph2m
                    else
                        return MAX_AUTO_SPEED
                    end
                end

                function updateAutoDescent() 
                    if navSurfacePos then
                        updateAutoTranslate(navSurfacePos)
                    end

                    if (core.getAltitude() <= DESCENT_MIN_BRAKE_ALT) then
                        zTargetVel = -DESCENT_SURFACE_VELOCITY
                    else
                        zTargetVel = -DESCENT_SPACE_VELOCITY
                    end

                    if core.getAltitude() <= DESCENT_STOP_ALT + navAlt then
                        unit.extendLandingGears()
                        setAutopilotMode(AUTOPILOT_MODE_HOVER)
                        zTargetVel = -DESCENT_FINAL_VELOCTIY
                    end
                end

                function updateApproachFrame()
                    local destPos = getWaypointPos()
                    local currentPos = vec3(core.getConstructWorldPos())
                    local deltaPos = destPos - currentPos
                    local currentVel = vec3(core.getWorldVelocity())
                    local spd = currentVel:len()

                    if autopilotStage == APPROACH_STAGE_ACCELERATE then
                        if currentWaypoint > 0 then  -- Don't break until the last waypoint
                            local currentDist = deltaPos:len()

                            if currentDist < RADIAL_WP_RADIUS then
                                currentWaypoint = currentWaypoint - 1
                                updateApproachTick()
                            end
                        else
                            local brakeAccel = getMaxSpaceBrakeAccel()
                            local brakeDist = (spd / 2) * (spd / brakeAccel)
                            local currentDist = deltaPos:len() - navApproachDistance

                            if currentDist <= brakeDist then
                                setAutopilotStage(APPROACH_STAGE_BRAKE)
                                updateApproachTick()
                            end
                        end
                    elseif autopilotStage == APPROACH_STAGE_BRAKE then
                        if spd < 1 then 
                            if navType == NAV_TYPE_SPACE then
                                setAutopilotMode(AUTOPILOT_MODE_SPACE_ASSIST)
                            else 
                                setAutopilotMode(AUTOPILOT_MODE_DESCENT)
                            end
                        end
                    end
                end

                function updateApproachTick()                
                    local destPos = getWaypointPos()
                    local currentPos = vec3(core.getConstructWorldPos())
                    local deltaPos = destPos - currentPos
                    local currentVel = vec3(core.getWorldVelocity())
                    local spd = currentVel:len()

                    if autopilotStage == APPROACH_STAGE_ACCELERATE then
                        updateAutoCruiseDirection(deltaPos:normalize())
                    elseif autopilotStage == APPROACH_STAGE_BRAKE then
                        local accelVec = -vec3(core.getWorldGravity())
                        local targetVector = accelVec:normalize()
                        updateAutoAlignVector(targetVector)
                        autoAccelerationVector = accelVec
                    end
                end

                function updateAutoCruiseDirection(velDir)
                    local setSpeed = AUTO_CRUISE_DEFAULT_VELOCITY

                    if Nav.axisCommandManager:getMasterMode() == 1 then
                        setSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) * constants.kph2m
                    end

                    local targetVel = setSpeed * velDir
                    local currentVel = vec3(core.getWorldVelocity())
                    local deltaVel = targetVel - currentVel
                    local accelDir = deltaVel:normalize()
                    local maxAccel = getMaxAcceleration(accelDir)
                    
                    -- TODO: PID
                    local accelM = (deltaVel:len()) * 0.1

                    if accelM > maxAccel then
                        accelM = maxAccel
                    end

                    local accelVec = -vec3(core.getWorldGravity()) + accelM * accelDir
                    local targetVector = accelVec:normalize()
                    updateAutoAlignVector(targetVector)

                    local constructUp = vec3(core.getConstructWorldOrientationUp())
                    local constructForward = vec3(core.getConstructWorldOrientationForward())
                    local deltaAngle = math.acos(constructUp:dot(targetVector)) * constants.rad2deg

                    if deltaAngle > 15 then
                        autoAccelerationVector = -vec3(core.getWorldGravity())
                    else 
                        autoAccelerationVector = accelVec
                    end
                end

                -- Get maximum acceleration in the given direction
                function getMaxAcceleration(accelDir) 
                    local vertical = -vec3(core.getWorldVertical())
                    local csX = vertical:cross(accelDir):normalize_inplace()
                    local csY = vertical:cross(csX):normalize_inplace()
                    local csZ = vertical
                    local csMat = createMatrix(csX, csY, csZ)
                    local cvMat = matrixInvert(csMat)
                    local cvDir = matrixXVec(cvMat, accelDir)
                    local grav = core.g()
                    local maxAccel = getMaxSpaceAccel()

                    local coefA = cvDir.z * cvDir.z + cvDir.y * cvDir.y
                    local coefB = 2 * cvDir.z * grav
                    local coefC = grav * grav - maxAccel * maxAccel
                    local result = solveQuad(coefA, coefB, coefC)

                    -- -- < 0 means we don't have enough acceleration to fight gravity. Oh well.
                    if result < 0 then
                        return 0
                    end
                    return result
                end

                function updateAutoAlignVector(autoAlignTargetVector)
                    local constructUp = vec3(core.getConstructWorldOrientationUp())
                    local constructForward = vec3(core.getConstructWorldOrientationForward())

                    rz = autoAlignTargetVector:cross(constructUp):normalize_inplace()
                    local rx = autoAlignTargetVector
                    local ry = rz:cross(autoAlignTargetVector):normalize_inplace()
                    local csMat = createMatrix(rx, ry, rz)
                    autoAlignMatrix = matrixInvert(csMat)
                    -- autoAlignPID:reset()
                end

                function updateAutoTranslate(targetPos)
                    local currentPos = vec3(core.getConstructWorldPos())
                    local deltaPos = targetPos - currentPos

                    -- Create vehichle local CS
                    local constructUp = vec3(core.getConstructWorldOrientationUp())
                    local constructForward = vec3(core.getConstructWorldOrientationForward())
                    local constructRight = vec3(core.getConstructWorldOrientationRight())
                    local csMat = createMatrix(constructRight, constructForward, constructUp)
                    local ivMat = matrixInvert(csMat)
                    localDeltaPos = matrixXVec(ivMat, deltaPos)

                    xTargetVelPID:inject(localDeltaPos.x)
                    yTargetVelPID:inject(localDeltaPos.y)
                    zTargetVelPID:inject(localDeltaPos.z)
                    
                    xTargetVel = xTargetVelPID:get()
                    yTargetVel = yTargetVelPID:get()
                    zTargetVel = zTargetVelPID:get()
                end

                -- Convert surface coords

                function getWaypointPos()
                    if currentWaypoint > 0 and additionalWaypoints[currentWaypoint] then
                        return additionalWaypoints[currentWaypoint]
                    else
                        return navSpacePos
                    end
                end

                function updateNavSurfacePos()
                    if navType == NAV_TYPE_PLANET then
                        navSurfacePos = getSurfaceNavPosWithExtraAlt(0)
                    end
                end

                function updateNavSpacePos()
                    if navType == NAV_TYPE_PLANET then
                        navSpacePos = getSurfaceNavPosWithExtraAlt(DESCENT_START_ALT)
                    end
                end

                function getSurfaceNavPosWithExtraAlt(extraAlt)
                    local theCenter = getTheCenter()
                    local lat = navLat
                    local long = navLong
                    local alt = navAlt + extraAlt
    
                    local z = math.sin(lat * constants.deg2rad)
                    local xy = math.cos(lat * constants.deg2rad)
    
                    local x = xy * math.cos(long * constants.deg2rad)
                    local y = xy * math.sin(long * constants.deg2rad)
    
                    local distFromCenter = alt + navPlanetDepth
                    local vFrom = vec3(x, y, z)
                    return vFrom * distFromCenter + theCenter
                end

                function getTheCenter() 
                    local alt = core.getAltitude()
                    local gravity = vec3(core.getWorldGravity())
                    local toCenter = gravity:normalize() * (navPlanetDepth + alt)
                    return vec3(core.getConstructWorldPos()) + toCenter
                end

                -- Getters

                function isAutoOrientationEnabled() 
                    return autopilotMode == AUTOPILOT_MODE_HOVER or autopilotMode == AUTOPILOT_MODE_DESCENT or autopilotMode == AUTOPILOT_MODE_LAUNCH
                end

                function getMaxSpaceAccel()
                    local params = core.getMaxKinematicsParametersAlongAxis("thrust analog", {0, 0, 1})
                    return params[3] / core.getConstructMass()
                end
                
                function getMaxSpaceBrakeAccel()
                    if not spacebrake then 
                        return 0
                    end

                    return spacebrake.getMaxThrustBase() * SPACE_BRAKE_COUNT / core.getConstructMass()
                end

                function getMaxRocketAccel() 
                    local params = core.getMaxKinematicsParametersAlongAxis("rocket_engine", {0, 0, 1})
                    return params[3] / core.getConstructMass()
                end

                function getRocketFuelMass() 
                    if not rocketfueltank_1 then
                        return 0
                    end
                    return rocketfueltank_1.getItemsMass()
                end

                isManualTranslationEnabled = function()
                    return autopilotMode == AUTOPILOT_MODE_MANUAL
                end

                isManualBrakeEnabled = function() 
                    return autopilotMode == AUTOPILOT_MODE_MANUAL
                end

                function isTranslationAssistEnabled()
                    return  autopilotMode == AUTOPILOT_MODE_HOVER or autopilotMode == AUTOPILOT_MODE_SPACE_ASSIST
                end

                function isManualRotationEnabled() 
                    return autopilotMode == AUTOPILOT_MODE_MANUAL or autopilotMode == AUTOPILOT_MODE_SPACE_ASSIST or autopilotMode == AUTOPILOT_MODE_CRUISE
                end

                function isManualBoostEnabled() 
                    return autopilotMode == AUTOPILOT_MODE_MANUAL or autopilotMode == AUTOPILOT_MODE_SPACE_ASSIST or autopilotMode == AUTOPILOT_MODE_HOVER
                end

                function shouldAutoAlign()
                    return autopilotMode == AUTOPILOT_MODE_APPROACH
                end

                unit.setTimer('COURSE_CORRECTION_TIMER', 0.1)

        flush:
            lua: |
                updateAutopilot()

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = 0

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(core.getConstructWorldOrientationUp())
                local constructForward = vec3(core.getConstructWorldOrientationForward())
                local constructRight = vec3(core.getConstructWorldOrientationRight())
                local constructVelocity = vec3(core.getWorldVelocity())
                local constructVelocityDir = vec3(core.getWorldVelocity()):normalize_inplace()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)
                local constructAngularVelocity = vec3(core.getWorldAngularVelocity())
                local constructYawVelocity = constructAngularVelocity:dot(constructUp)
                local targetAngularVelocity = vec3(0, 0, 0)

                -- Brakes
                if autoBrakeEnabled then
                    finalBrakeInput = 1
                elseif isManualBrakeEnabled() then
                    finalBrakeInput = brakeInput
                end
                brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)

                -- Rotation

                if shouldAutoAlign() then
                    local rotationVec = matrixXVec(autoAlignMatrix, constructUp)
                    dAngle = math.asin(rotationVec.y) * constants.rad2deg
                    autoAlignPID:inject(-dAngle)
                    targetAngularVelocity = autoAlignPID:get() * rz
                elseif isAutoOrientationEnabled() then
                    local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                    local currentPitchDeg = -math.asin(constructForward:dot(worldVertical)) * constants.rad2deg
                    rollPID:inject(targetRollDeg - currentRollDeg)
                    pitchPID:inject(targetPitchDeg - currentPitchDeg)
    
                    targetAngularVelocity = rollPID:get() * constructForward
                                                            + pitchPID:get() * constructRight
                                                            + finalYawInput * yawSpeedFactor * constructUp
                else
                    targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                    + finalRollInput * rollSpeedFactor * constructForward
                                                    + finalYawInput * yawSpeedFactor * constructUp
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                if engineCut == 1 then
                    local engineTags = 'thrust'
                    local accel = vec3(0, 0, 0)
                    Nav:setEngineForceCommand(engineTags, accel, keepCollinearity)            
                    
                elseif autopilotMode == AUTOPILOT_MODE_APPROACH then
                    local engineTags = 'thrust analog'
                    Nav:setEngineForceCommand(engineTags, autoAccelerationVector, keepCollinearity)

                    if autopilotStage == APPROACH_STAGE_BRAKE then 
                        local brakeAccel = MAX_ACCELERATION
                        brakeAcceleration = -brakeAccel * constructVelocityDir
                    end
                
                elseif isManualTranslationEnabled() or autopilotMode == AUTOPILOT_MODE_LAUNCH then
                    -- Longitudinal Translation
                    local longitudinalEngineTags = 'thrust analog longitudinal'
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration * constructForward, keepCollinearity)

                    -- Lateral Translation
                    local lateralStrafeEngineTags = 'thrust analog lateral'
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralAcceleration * constructRight, keepCollinearity)

                    -- Vertical Translation
                    local verticalStrafeEngineTags = 'thrust analog vertical'
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalAcceleration * constructUp, keepCollinearity)
                
                elseif isTranslationAssistEnabled() or autopilotMode == AUTOPILOT_MODE_DESCENT or autopilotMode == AUTOPILOT_MODE_CRUISE then
                    local ta_accel = vec3(0, 0, 0)

                    local currentVelocity = vec3(core.getVelocity())
                    xAccelPID:inject(xTargetVel - currentVelocity.x)
                    yAccelPID:inject(yTargetVel - currentVelocity.y)
                    zAccelPID:inject(zTargetVel - currentVelocity.z)

                    local originalZAccel = zAccelPID:get()
                    local zAccel = originalZAccel

                    -- Always max accel while boosting
                    if Nav.boosterState == 1 then
                        zAccel = MAX_ACCELERATION
                    -- clamp zAccel while hovering so we don't decend too fast an crash
                    elseif autopilotMode == AUTOPILOT_MODE_HOVER or (autopilotMode == AUTOPILOT_MODE_DESCENT and core.getAltitude() <= DESCENT_MIN_BRAKE_ALT) then
                        local minAccel = -core.g() / 2

                        if zAccel < minAccel then
                            zAccel = minAccel
                        end
                    end

                    local xAccelCoef = 1
                    local yAccelCoef = 1

                    if autopilotMode == AUTOPILOT_MODE_HOVER and targetRollDeg ~= 0 then
                        xAccelCoef = 1 / math.cos(targetRollDeg * constants.deg2rad)
                    end

                    if autopilotMode == AUTOPILOT_MODE_HOVER and targetPitchDeg ~= 0 then
                        yAccelCoef = 1 / math.cos(targetPitchDeg * constants.deg2rad)
                    end

                    local yAccel = yAccelPID:get()

                    ta_accel = xAccelPID:get() * xAccelCoef * constructRight + yAccel * yAccelCoef * constructForward + zAccel * constructUp

                    local engineTags = 'thrust analog'
                    local brakeAccel = 0

                    -- Hover Auto Brake
                    if (autopilotMode == AUTOPILOT_MODE_DESCENT and (core.getAltitude() <= DESCENT_MIN_BRAKE_ALT or (math.abs(localDeltaPos.x) <= 5 and math.abs(localDeltaPos.y) <= 5)))
                        or (autopilotMode == AUTOPILOT_MODE_HOVER and xTargetVel == 0 and yTargetVel == 0 and zTargetVel <= 0 and targetRollDeg == 0 and targetPitchDeg == 0 and yawInput == 0) then
                            
                        if unit.getAtmosphereDensity() < 0.1 then
                            if originalZAccel < 0 then 
                                brakeAccel = core.g() * 0.75
                            else 
                                brakeAccel = core.g()
                            end
                        else
                            brakeAccel = MAX_ACCELERATION
                            ta_accel = ta_accel - vec3(core.getWorldGravity())
                        end
                    else
                        if (autopilotMode == AUTOPILOT_MODE_SPACE_ASSIST and xTargetVel == 0 and yTargetVel == 0 and zTargetVel == 0 and pitchInput == 0 and rollInput == 0 and yawInput == 0)
                            or autopilotMode == AUTOPILOT_MODE_CRUISE and zAccel < 0 then
                            brakeAccel = MAX_ACCELERATION
                        end
                        ta_accel = ta_accel - vec3(core.getWorldGravity())
                    end

                    Nav:setEngineForceCommand(engineTags, ta_accel, keepCollinearity)

                    brakeAcceleration = -brakeAccel * constructVelocityDir
                end

                -- Final Brake 
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')

        update:
            lua: |
                Nav:update()
                updatePanels()

        actionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end

        actionStart:
            args: [light]
            lua: |
                if Nav.control.isAnyHeadlightSwitchedOn() == 1 then
                    Nav.control.switchOffHeadlights()
                else
                    Nav.control.switchOnHeadlights()
                end

        actionStart:
            args: [forward]
            lua: |
                if isManualRotationEnabled() then
                    pitchInput = -1
                elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                    targetPitchDeg = -10
                end 
            
        actionStop:
            args: [forward]
            lua: |
                if isManualRotationEnabled() then
                    pitchInput = 0
                elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                    targetPitchDeg = 0 
                end
                
        actionStart:
            args: [backward]
            lua: |
                if isManualRotationEnabled() then
                    pitchInput = 1
                elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                    targetPitchDeg = 10
                end

        actionStop:
            args: [backward]
            lua: |
                if isManualRotationEnabled() then
                    pitchInput = 0
                elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                    targetPitchDeg = 0 
                end

        actionStart:
            args: [strafeleft]
            lua: |
                if isManualRotationEnabled() or autopilotMode == AUTOPILOT_MODE_HOVER  then
                    yawInput = 1
                end

        actionStop:
            args: [strafeleft]
            lua: |
                if isManualRotationEnabled() or autopilotMode == AUTOPILOT_MODE_HOVER  then
                    yawInput = 0
                end

        actionStart:
            args: [straferight]
            lua: |
                if isManualRotationEnabled() or autopilotMode == AUTOPILOT_MODE_HOVER  then
                    yawInput = -1
                end

        actionStop:
            args: [straferight]
            lua: |
                if isManualRotationEnabled() or autopilotMode == AUTOPILOT_MODE_HOVER   then
                    yawInput = 0
                end

        actionStart:
            args: [yawright]
            lua:  |
                if isManualRotationEnabled() then
                    rollInput = -1
                elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                    targetRollDeg = -10 
                end


        actionStop:
            args: [yawright]
            lua: |
                if isManualRotationEnabled() then
                    rollInput = 0
                elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                    targetRollDeg = 0
                end


        actionStart:
            args: [yawleft]
            lua:  |
                if isManualRotationEnabled() then
                    rollInput = 1
                elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                    targetRollDeg = 10
                end


        actionStop:
            args: [yawleft]
            lua:  |
                if isManualRotationEnabled() then
                    rollInput = 0
                elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                    targetRollDeg = 0
                end

        actionStart:
            args: [right]
            lua: |
                if isManualTranslationEnabled() then
                    lateralAcceleration = MAX_ACCELERATION
                elseif isTranslationAssistEnabled() then
                    xTargetVel = getTargetSpeed()
                end
            
        actionStop:
            args: [right]
            lua: |
                if isManualTranslationEnabled() then
                    lateralAcceleration = 0
                elseif isTranslationAssistEnabled() and not leftShiftPressed then
                    xTargetVel = 0
                end

        actionStart:
            args: [left]
            lua: |
                if isManualTranslationEnabled() then
                    lateralAcceleration = -MAX_ACCELERATION
                elseif isTranslationAssistEnabled() then
                    xTargetVel = -getTargetSpeed()
                end

        actionStop:
            args: [left]
            lua: |
                if isManualTranslationEnabled() then
                    lateralAcceleration = 0
                elseif isTranslationAssistEnabled() and not leftShiftPressed then
                    xTargetVel = 0
                end

        actionStart:
            args: [up]
            lua: |
                if isManualTranslationEnabled() then
                    verticalAcceleration = MAX_ACCELERATION
                elseif isTranslationAssistEnabled() then
                    zTargetVel = getTargetSpeed()
                elseif autopilotMode == AUTOPILOT_MODE_LAUNCH and autopilotStage == 0 then
                    setAutopilotStage(LAUNCH_STAGE_ENGINE_RAMP_UP)
                end
                
        actionStop:
            args: [up]
            lua: |
                if isManualTranslationEnabled() then
                    verticalAcceleration = 0
                elseif isTranslationAssistEnabled() and not leftShiftPressed then
                    zTargetVel = 0
                end
                
        actionStart:
            args: [down]
            lua: |
                if isManualTranslationEnabled() then
                    verticalAcceleration = -MAX_ACCELERATION
                elseif isTranslationAssistEnabled() then
                    zTargetVel = -getTargetSpeed()
                end
                
        actionStop:
            args: [down]
            lua: |
                if isManualTranslationEnabled() then
                    verticalAcceleration = 0
                elseif isTranslationAssistEnabled() and not leftShiftPressed then
                    zTargetVel = 0
                end

        actionStart:
            args: [groundaltitudeup]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 10.0)

        actionStart:
            args: [groundaltitudedown]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -10.0)

        actionStart:
            args: [brake]
            lua: |
                isCtrlPressed = true

        actionStop:
            args: [brake]
            lua: |
                isCtrlPressed = false

        actionStart:
            args: [booster]
            lua:  |
                if isManualBoostEnabled() then
                    Nav:toggleBoosters()
                    hoverSlamArmed = false
                end

        actionStart:
            args: [stopengines]
            lua: |
                if leftShiftPressed then 
                    Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
                elseif isCtrlPressed then 
                    engineCut = 1 - engineCut

                    if (engineCut) then
                        setBoosters(false)
                    end
                else
                    if isManualBrakeEnabled() then
                        brakeInput = 1
                    elseif isTranslationAssistEnabled() then
                        xTargetVel = 0
                        yTargetVel = 0
                        zTargetVel = 0
                    end
                end

        actionStop:
            args: [stopengines]
            lua: |
                brakeInput = 0

        actionStart:
            args: [speedup]
            lua:  |
                if isManualTranslationEnabled() then
                    longitudinalAcceleration = MAX_ACCELERATION
                elseif isTranslationAssistEnabled() then
                    yTargetVel = getTargetSpeed()
                end
                
        actionStop:
            args: [speedup]
            lua:  |
                if isManualTranslationEnabled() then
                    longitudinalAcceleration = 0
                elseif isTranslationAssistEnabled() and not leftShiftPressed then
                    yTargetVel = 0
                end

        actionStart:
            args: [speeddown]
            lua:  |
                if isManualTranslationEnabled() then
                    longitudinalAcceleration = -MAX_ACCELERATION
                elseif isTranslationAssistEnabled() then
                    yTargetVel = -getTargetSpeed()
                end

        actionStop:
            args: [speeddown]
            lua:  |
                if isManualTranslationEnabled() then
                    longitudinalAcceleration = 0
                elseif isTranslationAssistEnabled() and not leftShiftPressed then
                    yTargetVel = 0
                end

        actionStart:
            args: [antigravity]
            lua:  |
                if autopilotMode == AUTOPILOT_MODE_MANUAL then
                    if antigrav ~= nil then antigrav.toggle() end
                end

        actionStart:
            args: [warp]
            lua:  |
                if autopilotMode == AUTOPILOT_MODE_MANUAL then
                    if warpdrive ~= nil then warpdrive.activateWarp() end
                end

        actionStart:
            args: [lshift]
            lua: |
                leftShiftPressed = true

        
        actionStop:
            args: [lshift]
            lua: |
                leftShiftPressed = false

        actionStart:
            args: [option1]
            lua:  |
                if isCtrlPressed then
                    hoverSlamArmed = 1 - hoverSlamArmed
                elseif leftShiftPressed then 
                    if nav1 then
                        selectNavPoint(nav1)
                    end
                else
                    setAutopilotMode(AUTOPILOT_MODE_MANUAL)
                end

        actionStart:
            args: [option2]
            lua:  |
                if leftShiftPressed then 
                    if nav2 then
                        selectNavPoint(nav2)
                    end
                else
                    setAutopilotMode(AUTOPILOT_MODE_HOVER)
                end

        actionStart:
            args: [option3]
            lua:  |
                if leftShiftPressed then 
                    if nav3 then
                        selectNavPoint(nav3)
                    end
                else
                    setAutopilotMode(AUTOPILOT_MODE_SPACE_ASSIST)
                end

        actionStart:
            args: [option4]
            lua:  |
                if leftShiftPressed then 
                    if nav4 then
                        selectNavPoint(nav4)
                    end
                else
                    setAutopilotMode(AUTOPILOT_MODE_LAUNCH)
                end
                
        actionStart:
            args: [option5]
            lua:  |
                if leftShiftPressed then 
                    if nav5 then
                        selectNavPoint(nav5)
                    end
                else
                    setAutopilotMode(AUTOPILOT_MODE_CRUISE)
                end

        actionStart:
            args: [option6]
            lua:  |
                if isCtrlPressed then
                    setAutopilotMode(AUTOPILOT_MODE_DESCENT)
                elseif leftShiftPressed then 
                    if nav6 then
                        selectNavPoint(nav6)
                    end
                else
                    currentWaypoint = 0
                    setAutopilotMode(AUTOPILOT_MODE_APPROACH)
                end

        actionStart:
            args: [option7]
            lua:  |
                if leftShiftPressed then 
                    if nav7 then
                        selectNavPoint(nav7)
                    end
                else 
                    generateRadialWaypoints()
                    setAutopilotMode(AUTOPILOT_MODE_APPROACH)
                end

        actionStart:
            args: [option8]
            lua:  |
                if leftShiftPressed then 
                    if nav8 then
                        selectNavPoint(nav8)
                    end
                end