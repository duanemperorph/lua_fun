# This is a file describing a standard autoconfiguration, do not edit.
# See custom/sample.conf for a more generic template and explanation on the syntax.

name: Auto Rocket

slots:
    core:
        class: CoreUnit
    antigrav:
        class: AntiGravityGeneratorUnit
    warpdrive:
        class: WarpDriveUnit
    atmofueltank:
        class: AtmoFuelContainer
        select: all
    spacefueltank:
        class: SpaceFuelContainer
        select: all
    rocketfueltank:
        class: RocketFuelContainer
        select: all
    rocketengine:
        class: RocketEngine
        select: all
    gyro:
        class: GyroUnit
    weapon:
        class: WeaponUnit
        select: manual
    radar:
        class: RadarPVPUnit
        select: manual

handlers:
    unit:
        start:
            lua: |
                nav1 = {
                    name = "spazPad",
                    loc = "::pos{0,26,-6.9926,3.6189,66.9041}"
                }

                nav2 = {
                    name = "spazBaz",
                    loc = "::pos{0,0,-1233489.8236,463419.2081,-317880.0588}"
                }

                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {100, 500, 1000, 5000, 10000, 100000, 1000000})
                Nav.axisCommandManager:setTargetGroundAltitude(4)

                -- element widgets
                -- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.
                _autoconf.displayCategoryPanel(weapon, weapon_size, L_TEXT("ui_lua_widget_weapon", "Weapons"), "weapon", true)
                core.show()
                _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_periscope", "Periscope"), "periscope")
                placeRadar = true
                if atmofueltank_size > 0 then
                    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"), "fuel_container")
                    if placeRadar then
                        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        placeRadar = false
                    end
                end
                if spacefueltank_size > 0 then
                    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"), "fuel_container")
                    if placeRadar then
                        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        placeRadar = false
                    end
                end
                _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"), "fuel_container")
                if placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels
                    _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                    placeRadar = false
                end
                if antigrav ~= nil then antigrav.show() end
                if warpdrive ~= nil then warpdrive.show() end
                if gyro ~= nil then gyro.show() end

                -- freeze the player in he is remote controlling the construct
                if Nav.control.isRemoteControlled() == 1 then
                    system.freeze(1)
                end

                -- landing gear
                -- make sure every gears are synchonized with the first
                gearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end

                velocityPanel = system.createWidgetPanel("Velocity")
                velocityWidget = system.createWidget(velocityPanel, "value")
                velocityXData = system.createData()
                velocityYData = system.createData()
                velocityZData = system.createData()
                system.addDataToWidget(velocityXData, velocityWidget)
                system.addDataToWidget(velocityYData, velocityWidget)
                system.addDataToWidget(velocityZData, velocityWidget)


                autopilotPanel = system.createWidgetPanel("Autopilot")
                autopilotWidget = system.createWidget(autopilotPanel, "value")
                modeWidgetData = system.createData()
                system.addDataToWidget(modeWidgetData, autopilotWidget)
                stageWidgetData = system.createData()
                system.addDataToWidget(stageWidgetData, autopilotWidget)
                brakeWidgetData = system.createData()
                system.addDataToWidget(brakeWidgetData, autopilotWidget)
                engineCutWidgetData = system.createData()
                system.addDataToWidget(engineCutWidgetData, autopilotWidget)
                hoverSlamWidgetData = system.createData()
                system.addDataToWidget(hoverSlamWidgetData, autopilotWidget)

                navPanel = system.createWidgetPanel("Nav")
                navWidget = system.createWidget(navPanel, "value")
                navNameData = system.createData()
                navTypeData = system.createData()
                navXData = system.createData()
                navYData = system.createData()
                navZData = system.createData()
                navLatData = system.createData()
                navLongData = system.createData()
                navAltData = system.createData()
                system.addDataToWidget(navNameData, navWidget)
                system.addDataToWidget(navTypeData, navWidget)
                system.addDataToWidget(navXData, navWidget)
                system.addDataToWidget(navYData, navWidget)
                system.addDataToWidget(navZData, navWidget)
                system.addDataToWidget(navLatData, navWidget)
                system.addDataToWidget(navLongData, navWidget)
                system.addDataToWidget(navAltData, navWidget)


                debugPanel = system.createWidgetPanel("Debug")
                debugWidget = system.createWidget(debugPanel, "value")
                debugData1 = system.createData()
                debugData2 = system.createData()
                debugData3 = system.createData()
                debugData4 = system.createData()
                debugData5 = system.createData()
                debugData6 = system.createData()
                system.addDataToWidget(debugData1, debugWidget)
                system.addDataToWidget(debugData2, debugWidget)
                system.addDataToWidget(debugData3, debugWidget)
                system.addDataToWidget(debugData4, debugWidget)
                system.addDataToWidget(debugData5, debugWidget)
                system.addDataToWidget(debugData6, debugWidget)

                updateValueWidgetData = function(widget, label, value, units)
                    local data = '{"label": "_LABEL_", "value": "_VALUE_", "unit": "_UNIT_"}'
                    data = string.gsub(data, '_LABEL_', label)
                    data = string.gsub(data, '_VALUE_', value)
                    data = string.gsub(data, '_UNIT_', units or '')
                    system.updateData(widget, data)
                end

                updateAutopilotWidget = function()
                    local autopilotModeName = ""

                    if (autopilotMode == AUTOPILOT_MODE_MANUAL) then
                        autopilotModeName = 'Manual (1)'
                    elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                        autopilotModeName = "Hover (2)"
                    elseif autopilotMode == AUTOPILOT_MODE_SPACE_ASSIST then
                        autopilotModeName = "Space Asist (3)"
                    elseif autopilotMode == AUTOPILOT_MODE_LAUNCH then
                        autopilotModeName = "Launch (4)"
                    elseif autopilotMode == AUTOPILOT_MODE_DESCENT then
                        autopilotModeName = "Descent (5)"
                    elseif autopilotMode == AUTOPILOT_MODE_APPROACH then
                        autopilotModeName = "Approach (6)"
                    end

                    updateValueWidgetData(modeWidgetData, 'MODE', autopilotModeName)
                end

                updatePanels = function() 
                    local vel = vec3(core.getVelocity())
                    updateValueWidgetData(velocityXData, 'x', vel.x)
                    updateValueWidgetData(velocityYData, 'y', vel.y)
                    updateValueWidgetData(velocityZData, 'z', vel.z)

                    updateValueWidgetData(stageWidgetData, 'STAGE', autopilotStage)
                    updateValueWidgetData(brakeWidgetData, 'BRAKE', brakeAcceleration:len())
                    updateValueWidgetData(engineCutWidgetData, 'ENGINE CUT', engineCut)
                    updateValueWidgetData(hoverSlamWidgetData, 'HOVER SLAM', hoverSlamArmed)

                    updateAutopilotWidget()

                    updateValueWidgetData(debugData1, 'ROCKET_MAX_THRUST_Base', rocketengine_1.getMaxThrustBase())
                    updateValueWidgetData(debugData2, 'Rocket fuel mass', rocketfueltank_1.getItemsMass())

                    updateValueWidgetData(debugData3, 'atmo', unit.getAtmosphereDensity())

                    updateValueWidgetData(debugData4, 'tz', zTargetVel)
                    updateValueWidgetData(debugData5, 'planet', unit.getClosestPlanetInfluence())
                    -- updateValueWidgetData(debugData6, 'pz', ta_accel.z)

                    updateNavWidget()
                end

                -- Initial auto pilot mode
                setAutopilotMode(AUTOPILOT_MODE_MANUAL)

                function selectNavPoint(newNav) 
                    local systemNum, planetNum, lat, long, alt = newNav.loc:match("([%d//.-]+),([%d//.-]+),([%d//.-]+),([%d//.-]+),([%d//.-]+)")

                    -- Space coordinates
                    if math.ceil(planetNum) == 0 then
                        navX = lat
                        navY = long
                        navZ = alt
                        navLat = 0
                        navLong = 0
                        navAlt = 0
                        navType = NAV_TYPE_SPACE
                    else
                        -- TODO: Plantary approach mode
                        navX = 0
                        navY = 0
                        navZ = 0
                        navLat = lat
                        navLong = long
                        navAlt = alt
                        navType = NAV_TYPE_PLANET
                    end

                    navName = newNav.name
                end

                function updateNavWidget() 
                    updateValueWidgetData(navNameData, 'Name', navName)
                    updateValueWidgetData(navTypeData, 'Type', navType)
                    updateValueWidgetData(navXData, 'X', navX)
                    updateValueWidgetData(navYData, 'Y', navY)
                    updateValueWidgetData(navZData, 'Z', navZ)
                    updateValueWidgetData(navLongData, 'Long', navLong)
                    updateValueWidgetData(navLatData, 'Lat', navLat)
                    updateValueWidgetData(navAltData, 'Alt', navAlt)
                end

                selectNavPoint(nav1)
        stop:
            lua: |
                _autoconf.hideCategoryPanels()
                if antigrav ~= nil then antigrav.hide() end
                if warpdrive ~= nil then warpdrive.hide() end
                if gyro ~= nil then gyro.hide() end
                core.hide()
                Nav.control.switchOffHeadlights()

        tick:
            args: [LAUNCH_RAMP_UP_TIMER]
            lua: |
                setAutopilotStage(LAUNCH_STAGE_ENGINE_ACCENT)
                unit.stopTimer('LAUNCH_RAMP_UP_TIMER')

    system:
        start:
            lua: |
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu
                LAUNCH_MAX_ALTITUDE = 2000 --export: Altitude for rocket burn cut off
                LAUNCH_MAX_VELOCITY = 1000 --export: velocity for rocket burn cut off
                LAUNCH_MIN_FUEL_MASS = 160 --export: Min fuel capacity mass reminaing for rocket burn

                DESCENT_VELOCITY = 100 --export: Velocity while descending (m/s)
                DESCENT_STOP_ALT = 1000 --export: attempt to stop after this alt
                SLAM_TARGET_ALT = 100 --export: attempt to stop at this altitude using rocket motor (in addition to nav alt)
                SLAM_MAX_SPEED = 25 --export: enable emergency hoverslam if we're going faster than this

                pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                MAX_ACCELERATION = 1000
                MAX_AUTO_SPEED = 100000

                ENGINE_RAMP_UP_TIME = 6

                autopilotMode = 0
                autopilotStage = 0

                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput = 0
                brakeAcceleration = vec3(0,0,0)
                engineCut = 0
                gearExtended = false
                hoverSlamArmed = 0

                targetRollDeg =  0
                targetPitchDeg =  0

                longitudinalAcceleration = 0
                lateralAcceleration = 0 
                verticalAcceleration = 0

                rollPID = pid.new(0.2, 0, 10)
                pitchPID = pid.new(0.2, 0, 10)

                xAccelPID = pid.new(1, 0, 50)
                yAccelPID = pid.new(1, 0, 50)
                zAccelPID = pid.new(1, 0, 50)

                xTargetVel = 0
                yTargetVel = 0
                zTargetVel = 0

                navX = 0
                navY = 0
                navZ = 0
                navLong = 0
                navLat = 0
                navAlt = 0
                navType = 0
                navName = ""

                leftShiftPressed = false

                autoBrakeEnabled = false
                autoOrientationEnabled = false

                AUTOPILOT_MODE_MANUAL = 1
                AUTOPILOT_MODE_HOVER = 2
                AUTOPILOT_MODE_SPACE_ASSIST = 3
                AUTOPILOT_MODE_LAUNCH = 4
                AUTOPILOT_MODE_DESCENT = 5
                AUTOPILOT_MODE_APPROACH = 6

                LAUNCH_STAGE_ARMED = 0
                LAUNCH_STAGE_ENGINE_RAMP_UP = 1
                LAUNCH_STAGE_ENGINE_ACCENT = 2
                LAUNCH_STAGE_ROCKET_ACCENT = 3

                NAV_TYPE_SPACE = 0
                NAV_TYPE_PLANET = 1

                setAutopilotMode = function (newMode)
                    autopilotMode = newMode

                    if autopilotMode == AUTOPILOT_MODE_MANUAL then
                        pitchInput = 0
                        rollInput = 0
                        yawInput = 0
                        brakeInput = 0
                        longitudinalAcceleration = 0
                        lateralAcceleration = 0
                        verticalAcceleration = 0
                        autoBrakeEnabled = false
                        stopAutoOrientation()
                    elseif autopilotMode == AUTOPILOT_MODE_SPACE_ASSIST or autopilotMode == AUTOPILOT_MODE_HOVER then
                        xTargetVel = 0
                        yTargetVel = 0
                        zTargetVel = 0
                    elseif autopilotMode == AUTOPILOT_MODE_DESCENT then
                        xTargetVel = 0
                        yTargetVel = 0
                        zTargetVel = -DESCENT_VELOCITY
                    end

                    if autopilotMode == AUTOPILOT_MODE_HOVER or autopilotMode == AUTOPILOT_MODE_DESCENT then
                        startAutoOrientation()
                    end

                    if autopilotMode == AUTOPILOT_MODE_DESCENT then 
                        hoverSlamArmed = 1
                    end

                    setBoosters(false)
                    setAutopilotStage(0)
                end
                
                setAutopilotStage = function (newStage)
                    autopilotStage = newStage

                    if autopilotMode == AUTOPILOT_MODE_LAUNCH then
                        if autopilotStage == LAUNCH_STAGE_ARMED then
                            autoBrakeEnabled = true
                            startAutoOrientation()
                        elseif autopilotStage == LAUNCH_STAGE_ENGINE_RAMP_UP then 
                            autoBrakeEnabled = false
                            longitudinalAcceleration = 0
                            lateralAcceleration = 0
                            verticalAcceleration = MAX_ACCELERATION
                            gearExtended = unit.isAnyLandingGearExtended() == 1
                            unit.setTimer('LAUNCH_RAMP_UP_TIMER', ENGINE_RAMP_UP_TIME)
                        elseif autopilotStage == LAUNCH_STAGE_ROCKET_ACCENT then
                            setBoosters(true)
                        end
                    end
                end

                updateAutopilot = function() 
                    local alt = core.getAltitude()
                    local vel = vec3(core.getVelocity())
                    local accel = vec3(core.getAcceleration())

                    if autopilotMode == AUTOPILOT_MODE_LAUNCH then
                        if vel.z > 1 and gearExtended then
                            unit.retractLandingGears()
                            gearExtended = false
                        end

                        if autopilotStage == LAUNCH_STAGE_ENGINE_ACCENT and accel.z <= 0 then
                            setAutopilotStage(LAUNCH_STAGE_ROCKET_ACCENT)
                        elseif autopilotStage == LAUNCH_STAGE_ROCKET_ACCENT and (vel.z >= LAUNCH_MAX_VELOCITY or alt >= LAUNCH_MAX_ALTITUDE or rocketfueltank_1.getItemsMass() <= LAUNCH_MIN_FUEL_MASS) then
                            setAutopilotMode(AUTOPILOT_MODE_SPACE_ASSIST)
                            zTargetVel = vel.z
                        end
                    elseif autopilotMode == AUTOPILOT_MODE_DESCENT then
                        if alt <= DESCENT_STOP_ALT then
                            unit.extendLandingGears()
                            setAutopilotMode(AUTOPILOT_MODE_HOVER)
                        end
                    end

                    if hoverSlamArmed == 1 and (autopilotMode == AUTOPILOT_MODE_DESCENT or autopilotMode == AUTOPILOT_MODE_HOVER) and unit.getClosestPlanetInfluence() > 0 then 
                        if Nav.boosterState == 0 and vel.z < -SLAM_MAX_SPEED then
                            local targetAlt = SLAM_TARGET_ALT
                            local brakeAccel = rocketengine_1.getMaxThrustBase() / core.getConstructMass()
                            -- TODO: Add atmo engine thrust variation
                            local gravAccel = -core.g()
                            local airResistance = core.g() + accel.z
                            local brakeDist = (vel.z / 2) * (vel.z / (brakeAccel + gravAccel + airResistance * 1.0))
                            local landingDist = alt - targetAlt

                            if landingDist < brakeDist then 
                                setBoosters(true)
                            end
                        elseif Nav.boosterState == 1 and vel.z >= 0 then
                            hoverSlamArmed = 0
                            setBoosters(false)
                        end
                    end
                end

                setBoosters = function (enabled)
                    if enabled then
                        Nav.boosterState = 1
                    else 
                        Nav.boosterState = 0
                    end
                    Nav.boosterStateHasChanged = true
                end

                function getTargetSpeed()
                    if Nav.axisCommandManager:getMasterMode() == 1 then
                        return Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) * constants.kph2m
                    else
                        return MAX_AUTO_SPEED
                    end
                end

                startAutoOrientation = function() 
                    autoOrientationEnabled = true
                    targetRollDeg =  0
                    targetPitchDeg =  0
                end

                function startAutoApproach() 

                end

                stopAutoOrientation = function()
                    autoOrientationEnabled = false
                end

                isManualTranslationEnabled = function()
                    return autopilotMode == AUTOPILOT_MODE_MANUAL
                end

                isManualBrakeEnabled = function() 
                    return autopilotMode == AUTOPILOT_MODE_MANUAL
                end

                function isTranslationAssistEnabled()
                    return  autopilotMode == AUTOPILOT_MODE_HOVER or autopilotMode == AUTOPILOT_MODE_SPACE_ASSIST
                end

                function isManualRotationEnabled() 
                    return autopilotMode == AUTOPILOT_MODE_MANUAL or autopilotMode == AUTOPILOT_MODE_SPACE_ASSIST
                end

                function isManualBoostEnabled() 
                    return autopilotMode == AUTOPILOT_MODE_MANUAL or autopilotMode == AUTOPILOT_MODE_SPACE_ASSIST or autopilotMode == AUTOPILOT_MODE_HOVER
                end

        flush:
            lua: |
                updateAutopilot()

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = 0

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(core.getConstructWorldOrientationUp())
                local constructForward = vec3(core.getConstructWorldOrientationForward())
                local constructRight = vec3(core.getConstructWorldOrientationRight())
                local constructVelocity = vec3(core.getWorldVelocity())
                local constructVelocityDir = vec3(core.getWorldVelocity()):normalize()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)
                local constructAngularVelocity = vec3(core.getWorldAngularVelocity())
                local constructYawVelocity = constructAngularVelocity:dot(constructUp)
                local targetAngularVelocity = nil

                -- Brakes
                if autoBrakeEnabled then
                    finalBrakeInput = 1
                elseif isManualBrakeEnabled() then
                    finalBrakeInput = brakeInput
                elseif autopilotMode == AUTOPILOT_MODE_SPACE_ASSIST and xTargetVel == 0 and yTargetVel == 0 and zTargetVel == 0 and pitchInput == 0 and rollInput == 0 and yawInput == 0 then
                    finalBrakeInput = 1
                end
                brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)

                -- Rotation

                if autoOrientationEnabled then
                    local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                    local currentPitchDeg = -math.asin(constructForward:dot(worldVertical)) * constants.rad2deg
                    rollPID:inject(targetRollDeg - currentRollDeg)
                    pitchPID:inject(targetPitchDeg - currentPitchDeg)
    
                    targetAngularVelocity = rollPID:get() * constructForward
                                                            + pitchPID:get() * constructRight
                                                            + finalYawInput * yawSpeedFactor * constructUp
                else
                    targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                    + finalRollInput * rollSpeedFactor * constructForward
                                                    + finalYawInput * yawSpeedFactor * constructUp
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                if engineCut == 1 then
                    local engineTags = 'thrust'
                    local accel = vec3(0, 0, 0)
                    Nav:setEngineForceCommand(engineTags, accel, keepCollinearity)                   
                
                elseif isManualTranslationEnabled() or autopilotMode == AUTOPILOT_MODE_LAUNCH then
                    -- Longitudinal Translation
                    local longitudinalEngineTags = 'thrust analog longitudinal'
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration * constructForward, keepCollinearity)

                    -- Lateral Translation
                    local lateralStrafeEngineTags = 'thrust analog lateral'
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralAcceleration * constructRight, keepCollinearity)

                    -- Vertical Translation
                    local verticalStrafeEngineTags = 'thrust analog vertical'
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalAcceleration * constructUp, keepCollinearity)
                
                elseif isTranslationAssistEnabled() or autopilotMode == AUTOPILOT_MODE_DESCENT then
                    local currentVelocity = vec3(core.getVelocity())
                    xAccelPID:inject(xTargetVel - currentVelocity.x)
                    yAccelPID:inject(yTargetVel - currentVelocity.y)
                    zAccelPID:inject(zTargetVel - currentVelocity.z)

                    local originalZAccel = zAccelPID:get()
                    local zAccel = originalZAccel

                    -- Always max accel while boosting
                    if Nav.boosterState == 0 then
                        zAccel = MAX_ACCELERATION
                    -- clamp zAccel while hovering so we don't decend too fast an crash
                    elseif autopilotMode == AUTOPILOT_MODE_HOVER or autopilotMode == AUTOPILOT_MODE_DESCENT  then
                        local minAccel = -core.g() / 2

                        if zAccel < minAccel then
                            zAccel = minAccel
                        end
                    end

                    local xAccelCoef = 1
                    local yAccelCoef = 1

                    if autopilotMode == AUTOPILOT_MODE_HOVER and targetRollDeg ~= 0 then
                        xAccelCoef = 1 / math.cos(targetRollDeg * constants.deg2rad)
                    end

                    if autopilotMode == AUTOPILOT_MODE_HOVER and targetPitchDeg ~= 0 then
                        yAccelCoef = 1 / math.cos(targetPitchDeg * constants.deg2rad)
                    end

                    local ta_accel = xAccelPID:get() * xAccelCoef * constructRight + yAccelPID:get() * yAccelCoef * constructForward + zAccel * constructUp
                    local engineTags = 'thrust analog'
                    local brakeAccel = 0

                    -- Hover Auto Brake
                    if autopilotMode == AUTOPILOT_MODE_DESCENT or (autopilotMode == AUTOPILOT_MODE_HOVER and xTargetVel == 0 and yTargetVel == 0 and zTargetVel <= 0 and targetRollDeg == 0 and targetPitchDeg == 0 and yawInput == 0) then
                        if unit.getAtmosphereDensity() < 0.1 then
                            if originalZAccel < 0 then 
                                brakeAccel = core.g() * 0.75
                            else 
                                brakeAccel = core.g()
                            end
                        else
                            brakeAccel = MAX_ACCELERATION
                            ta_accel = ta_accel - vec3(core.getWorldGravity())
                        end
                    else
                        ta_accel = ta_accel - vec3(core.getWorldGravity())
                    end

                    Nav:setEngineForceCommand(engineTags, ta_accel, keepCollinearity)
                    brakeAcceleration = -brakeAccel * constructVelocityDir
                end

                -- Final Brake 
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')

        update:
            lua: |
                Nav:update()
                updatePanels()

        actionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end

        actionStart:
            args: [light]
            lua: |
                if Nav.control.isAnyHeadlightSwitchedOn() == 1 then
                    Nav.control.switchOffHeadlights()
                else
                    Nav.control.switchOnHeadlights()
                end

        actionStart:
            args: [forward]
            lua: |
                if isManualRotationEnabled() then
                    pitchInput = -1
                elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                    targetPitchDeg = -10
                end 
            
        actionStop:
            args: [forward]
            lua: |
                if isManualRotationEnabled() then
                    pitchInput = 0
                elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                    targetPitchDeg = 0 
                end
                
        actionStart:
            args: [backward]
            lua: |
                if isManualRotationEnabled() then
                    pitchInput = 1
                elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                    targetPitchDeg = 10
                end

        actionStop:
            args: [backward]
            lua: |
                if isManualRotationEnabled() then
                    pitchInput = 0
                elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                    targetPitchDeg = 0 
                end

        actionStart:
            args: [strafeleft]
            lua: |
                if isManualRotationEnabled() or autopilotMode == AUTOPILOT_MODE_HOVER then
                    yawInput = 1
                end

        actionStop:
            args: [strafeleft]
            lua: |
                if isManualRotationEnabled() or autopilotMode == AUTOPILOT_MODE_HOVER then
                    yawInput = 0
                end

        actionStart:
            args: [straferight]
            lua: |
                if isManualRotationEnabled() or autopilotMode == AUTOPILOT_MODE_HOVER then
                    yawInput = -1
                end

        actionStop:
            args: [straferight]
            lua: |
                if isManualRotationEnabled() or autopilotMode == AUTOPILOT_MODE_HOVER then
                    yawInput = 0
                end

        actionStart:
            args: [yawright]
            lua:  |
                if isManualRotationEnabled() then
                    rollInput = -1
                elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                    targetRollDeg = -10 
                end


        actionStop:
            args: [yawright]
            lua: |
                if isManualRotationEnabled() then
                    rollInput = 0
                elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                    targetRollDeg = 0
                end


        actionStart:
            args: [yawleft]
            lua:  |
                if isManualRotationEnabled() then
                    rollInput = 1
                elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                    targetRollDeg = 10
                end


        actionStop:
            args: [yawleft]
            lua:  |
                if isManualRotationEnabled() then
                    rollInput = 0
                elseif autopilotMode == AUTOPILOT_MODE_HOVER then
                    targetRollDeg = 0
                end

        actionStart:
            args: [right]
            lua: |
                if isManualTranslationEnabled() then
                    lateralAcceleration = MAX_ACCELERATION
                elseif isTranslationAssistEnabled() then
                    xTargetVel = getTargetSpeed()
                end
            
        actionStop:
            args: [right]
            lua: |
                if isManualTranslationEnabled() then
                    lateralAcceleration = 0
                elseif isTranslationAssistEnabled() and not leftShiftPressed then
                    xTargetVel = 0
                end

        actionStart:
            args: [left]
            lua: |
                if isManualTranslationEnabled() then
                    lateralAcceleration = -MAX_ACCELERATION
                elseif isTranslationAssistEnabled() then
                    xTargetVel = -getTargetSpeed()
                end

        actionStop:
            args: [left]
            lua: |
                if isManualTranslationEnabled() then
                    lateralAcceleration = 0
                elseif isTranslationAssistEnabled() and not leftShiftPressed then
                    xTargetVel = 0
                end

        actionStart:
            args: [up]
            lua: |
                if isManualTranslationEnabled() then
                    verticalAcceleration = MAX_ACCELERATION
                elseif isTranslationAssistEnabled() then
                    zTargetVel = getTargetSpeed()
                elseif autopilotMode == AUTOPILOT_MODE_LAUNCH and autopilotStage == 0 then
                    setAutopilotStage(LAUNCH_STAGE_ENGINE_RAMP_UP)
                elseif autopilotMode == AUTOPILOT_MODE_APPROACH then
                    startAutoApproach()
                end
                
        actionStop:
            args: [up]
            lua: |
                if isManualTranslationEnabled() then
                    verticalAcceleration = 0
                elseif isTranslationAssistEnabled() and not leftShiftPressed then
                    zTargetVel = 0
                end
                
        actionStart:
            args: [down]
            lua: |
                if isManualTranslationEnabled() then
                    verticalAcceleration = -MAX_ACCELERATION
                elseif isTranslationAssistEnabled() then
                    zTargetVel = -getTargetSpeed()
                end
                
        actionStop:
            args: [down]
            lua: |
                if isManualTranslationEnabled() then
                    verticalAcceleration = 0
                elseif isTranslationAssistEnabled() and not leftShiftPressed then
                    zTargetVel = 0
                end

        actionStart:
            args: [groundaltitudeup]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 2.0)

        actionStart:
            args: [groundaltitudedown]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -2.0)

        actionStart:
            args: [brake]
            lua: |
                if isManualBrakeEnabled() then
                    brakeInput = 1
                elseif isTranslationAssistEnabled() then
                    xTargetVel = 0
                    yTargetVel = 0
                    zTargetVel = 0
                end

        actionStop:
            args: [brake]
            lua: |
                brakeInput = 0

        actionStart:
            args: [booster]
            lua:  |
                if isManualBoostEnabled() then
                    Nav:toggleBoosters()
                    hoverSlamArmed = false
                end

        actionStart:
            args: [stopengines]
            lua: |
                engineCut = 1 - engineCut

                if (engineCut) then
                    setBoosters(false)
                end

        actionStart:
            args: [speedup]
            lua:  |
                if isManualTranslationEnabled() then
                    longitudinalAcceleration = MAX_ACCELERATION
                elseif isTranslationAssistEnabled() then
                    yTargetVel = getTargetSpeed()
                end
                
        actionStop:
            args: [speedup]
            lua:  |
                if isManualTranslationEnabled() then
                    longitudinalAcceleration = 0
                elseif isTranslationAssistEnabled() and not leftShiftPressed then
                    yTargetVel = 0
                end

        actionStart:
            args: [speeddown]
            lua:  |
                if isManualTranslationEnabled() then
                    longitudinalAcceleration = -MAX_ACCELERATION
                elseif isTranslationAssistEnabled() then
                    yTargetVel = -getTargetSpeed()
                end

        actionStop:
            args: [speeddown]
            lua:  |
                if isManualTranslationEnabled() then
                    longitudinalAcceleration = 0
                elseif isTranslationAssistEnabled() and not leftShiftPressed then
                    yTargetVel = 0
                end

        actionStart:
            args: [antigravity]
            lua:  |
                if autopilotMode == AUTOPILOT_MODE_MANUAL then
                    if antigrav ~= nil then antigrav.toggle() end
                end

        actionStart:
            args: [warp]
            lua:  |
                if autopilotMode == AUTOPILOT_MODE_MANUAL then
                    if warpdrive ~= nil then warpdrive.activateWarp() end
                end

        actionStart:
            args: [lshift]
            lua: |
                leftShiftPressed = true

        
        actionStop:
            args: [lshift]
            lua: |
                leftShiftPressed = false

        actionStart:
            args: [option1]
            lua:  |
                if leftShiftPressed then 
                    if nav1 then
                        selectNavPoint(nav1)
                    end
                else
                    setAutopilotMode(AUTOPILOT_MODE_MANUAL)
                end

        actionStart:
            args: [option2]
            lua:  |
                if leftShiftPressed then 
                    if nav2 then
                        selectNavPoint(nav2)
                    end
                else
                    setAutopilotMode(AUTOPILOT_MODE_HOVER)
                end

        actionStart:
            args: [option3]
            lua:  |
                if leftShiftPressed then 
                    if nav3 then
                        selectNavPoint(nav3)
                    end
                else
                    setAutopilotMode(AUTOPILOT_MODE_SPACE_ASSIST)
                end

        actionStart:
            args: [option4]
            lua:  |
                if leftShiftPressed then 
                    if nav4 then
                        selectNavPoint(nav4)
                    end
                else
                    setAutopilotMode(AUTOPILOT_MODE_LAUNCH)
                end
                
        actionStart:
            args: [option5]
            lua:  |
                if leftShiftPressed then 
                    if nav5 then
                        selectNavPoint(nav5)
                    end
                else
                    setAutopilotMode(AUTOPILOT_MODE_DESCENT)
                end

        actionStart:
            args: [option6]
            lua:  |
                if leftShiftPressed then 
                    if nav6 then
                        selectNavPoint(nav6)
                    end
                else
                    setAutopilotMode(AUTOPILOT_MODE_APPROACH)
                end

        actionStart:
            args: [option7]
            lua:  |
                if leftShiftPressed then 
                    if nav7 then
                        selectNavPoint(nav7)
                    end
                end

        actionStart:
            args: [option8]
            lua:  |
                if leftShiftPressed then 
                    if nav8 then
                        selectNavPoint(nav8)
                    end
                end

        actionStart:
            args: [option9]
            lua:  |
                hoverSlamArmed = 1 - hoverSlamArmed